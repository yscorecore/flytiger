<?xml version="1.0" encoding="utf-8"?>
<case>
  <input>
    <code><![CDATA[
using System.Collections.Generic;
using System.Linq;
namespace SourceGenerator.ConvertTo
{
    public class From
    {
        public string StrProp { get; set; }
        public int IntProp { get; set; }

        public int? NullableIntProp { get; set; }
        public int NullableIntProp2 { get; set; }
        public OneEnum OneEnumProp { get; set; }
        public OneEnum? NullableOneEnumProp { get; set; }
        public OneEnum NullableOneEnumProp2 { get; set; }

        public OneStruct OneStructProp { get; set; }

        public OneStruct? NullableOneStructProp { get; set; }

        public OneStruct NullableOneStructProp2 { get; set; }

        public OneClass OneClassProp { get; set; }
        public OneClass OneClassProp2 { get; set; }

        public IEnumerable<OneClass> ClassList { get; set; }

        public IEnumerable<OneClass> ClassList2 { get; set; }

        public string[] ArrayStringToArray { get; set; }
        public string[] ArrayStringToList { get; set; }
        public string[] ArrayStringToIList { get; set; }
        public string[] ArrayStringToICollection { get; set; }
        public string[] ArrayStringToIEnumerable { get; set; }
        public string[] ArrayStringToIQueryable { get; set; }
    }

    public enum OneEnum
    {
        One,
    }
    public struct OneStruct
    {
        public string StrProp { get; set; }
    }
    public struct OneClass
    {
        public string StrProp { get; set; }
    }
    public struct OtherStruct
    {
        public string StrProp { get; set; }
        public int IntProp { get; set; }
    }
    public struct OtherClass
    {
        public string StrProp { get; set; }
        public int IntProp { get; set; }
    }

    public class To
    {
        public string StrProp { get; set; }
        public int IntProp { get; set; }
        public int? NullableIntProp { get; set; }
        public int? NullableIntProp2 { get; set; }
        public OneEnum OneEnumProp { get; set; }
        public OneEnum? NullableOneEnumProp { get; set; }
        public OneEnum? NullableOneEnumProp2 { get; set; }

        public OneStruct OneStructProp { get; set; }

        public OneStruct? NullableOneStructProp { get; set; }

        public OneStruct? NullableOneStructProp2 { get; set; }

        public OneClass OneClassProp { get; set; }

        public OtherClass OneClassProp2 { get; set; }

        public List<OneClass> ClassList { get; set; }
        public List<OtherClass> ClassList2 { get; set; }

        public string[] ArrayStringToArray { get; set; }

        public List<string> ArrayStringToList { get; set; }
        public IList<string> ArrayStringToIList { get; set; }

        public ICollection<string> ArrayStringToICollection { get; set; }

        public IEnumerable<string> ArrayStringToIEnumerable { get; set; }

        public IQueryable<string> ArrayStringToIQueryable { get; set; }
    }

    [FlyTiger.Mapper(typeof(From),typeof(To))]
    [FlyTiger.Mapper(typeof(To),typeof(From))]
    public partial class Convertors
    { 
    
    }
}
            
            ]]></code>
  </input>
  <output>
    <code file="FlyTiger.MapperAttribute.g.cs"><![CDATA[using System;
namespace FlyTiger
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    sealed class MapperAttribute : Attribute
    {
        public MapperAttribute(Type sourceType, Type targetType)
        {

            SourceType = sourceType ?? throw new ArgumentNullException(nameof(sourceType));
            TargetType = targetType ?? throw new ArgumentNullException(nameof(targetType));
        }

        public Type SourceType { get; }
        public Type TargetType { get; }

        public string[] IgnoreProperties { get; set; }

        public string[] CustomMappings { get; set; }

        public MapperType MapperType { get; set; } = MapperType.All;
        
        public CheckType CheckType { get; set; } = CheckType.None;

    }
    [Flags]
    enum MapperType
    {
        Query = 1,
        Convert = 2,
        Update = 4,
        BatchUpdate = Convert | Update,
        All = Query | Convert | Update
    }
    [Flags]
    enum CheckType
    {
        None = 0,
        SourceMembersFullUsed = 1,
        TargetMembersFullFilled = 2,
        All = SourceMembersFullUsed | TargetMembersFullFilled
    }
    enum CollectionUpdateMode
    {
        Append = 0,
        Merge = 1,
        Update = 2
    }
}]]></code>
    <code file="FlyTiger.EFCoreQueryableExtensions.g.cs"><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace FlyTiger
{
    internal static class EFCoreQueryableExtensions
    {
        public static IQueryable<TResult> RebuildWithIncludeForEfCore<TResult>(this IQueryable<TResult> toQuery)
        {
            if (toQuery?.Expression is MethodCallExpression callExpression
                && callExpression.Method.Name == nameof(Queryable.Select) && callExpression.Method.DeclaringType == typeof(Queryable)
                && callExpression.Arguments.Count == 2)
            {
                var includePaths = FindIncludeCollectionLambda(callExpression.Arguments[0]);
                if (includePaths.Any())
                {
                    return toQuery.Provider.CreateQuery<TResult>(Expression.Call(
                         null,
                         callExpression.Method,
                         callExpression.Arguments[0], ReplaceSelectCollectionExpression(callExpression.Arguments[1], includePaths)
                     ));
                }
            }
            return toQuery;
        }
        static IList<MemberIncludePath> FindIncludeCollectionLambda(Expression expression)
        {
            var includeFinder = new IncludePathFinder();
            includeFinder.Visit(expression);
            return includeFinder.MemberIncludePaths;
        }
        static Expression ReplaceSelectCollectionExpression(Expression expression, IList<MemberIncludePath> includePaths)
        {
            var visitCollectionSelect = new CollectionSelectReplacer(includePaths);
            return visitCollectionSelect.Visit(expression);
        }
#pragma warning disable CS8603,CS8604,CS8618
        class IncludePathFinder : ExpressionVisitor
        {
            public List<MemberIncludePath> MemberIncludePaths { get; private set; } = new List<MemberIncludePath>();
            protected override Expression VisitMethodCall(MethodCallExpression node)
            {
                if ((node.Method.Name == "Include" || node.Method.Name == "ThenInclude") && node.Type.IsGenericType &&
                    node.Type.GetGenericTypeDefinition().FullName == "Microsoft.EntityFrameworkCore.Query.IIncludableQueryable`2")
                {
                    var quoteExpression = node.Arguments[1] as UnaryExpression;
                    var lambda = quoteExpression?.Operand as LambdaExpression;
                    var memberIncludePath = FindMemberExpression(lambda);
                    if (memberIncludePath != null)
                    {
                        MemberIncludePaths.Add(memberIncludePath);
                    }
                }
                return base.VisitMethodCall(node);
            }
            private MemberIncludePath FindMemberExpression(LambdaExpression lambdaExpression)
            {
                if (lambdaExpression == null) return null;
                if (lambdaExpression.ReturnType.IsGenericType == false)
                {

                    return null;
                }

                var itemType = GetItemType(lambdaExpression.ReturnType);
                if (itemType == null)
                {
                    return null;
                }
                MemberIncludePath result = new MemberIncludePath();
                var expression = lambdaExpression.Body;
                while (true)
                {
                    if (expression is MemberExpression member)
                    {
                        var memberItemType = GetItemType(member.Type);
                        if (memberItemType == itemType)
                        {
                            result.ItemType = memberItemType;
                            result.Member = member;
                            return result.HasCallPath ? result : null;
                        }
                        else
                        {
                            return null;
                        }

                    }
                    else if (expression is ParameterExpression)
                    {
                        return null;
                    }
                    else if (expression is MethodCallExpression method)
                    {
                        result.CallPaths.Insert(0, method);
                        expression = method.Arguments[0];
                    }
                    else
                    {
                        return null;
                    }
                }
                Type GetItemType(Type sourceType)
                {
                    if (sourceType.IsArray)
                    {
                        return sourceType.GetElementType();
                    }
                    if (sourceType.IsGenericType && sourceType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                    {
                        return sourceType.GetGenericArguments().First();
                    }
                    return sourceType.GetInterfaces()
                          .Where(p => p.IsGenericType && p.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                          .Select(p => p.GetGenericArguments().First()).FirstOrDefault();
                }
            }
        }

        class CollectionSelectReplacer : ExpressionVisitor
        {
            private readonly IDictionary<MemberInfo, MemberIncludePath> memberPathsMap = new Dictionary<MemberInfo, MemberIncludePath>();

            public CollectionSelectReplacer(IEnumerable<MemberIncludePath> memberIncludePaths)
            {
                foreach (var memberIncludePath in memberIncludePaths)
                {
                    memberPathsMap[memberIncludePath.Member.Member] = memberIncludePath;
                }
            }
            protected override MemberAssignment VisitMemberAssignment(MemberAssignment node)
            {
                if (node.Expression is MemberExpression member && memberPathsMap.TryGetValue(member.Member, out var paths))
                {
                    return node.Update(ReplaceAndConvertExpression(member, paths));
                }

                return base.VisitMemberAssignment(node);
            }

            protected override Expression VisitMethodCall(MethodCallExpression node)
            {
              
                if (node.Method.DeclaringType == typeof(Enumerable) && node.Arguments[0] is MemberExpression member && memberPathsMap.TryGetValue(member.Member, out var paths))
                {
                    var arguments = node.Arguments.ToArray();
                    arguments[0] = ReplaceExpression(member, paths);
                    return Expression.Call(null, node.Method, arguments);
                }

                return base.VisitMethodCall(node);
            }
            protected override Expression VisitMember(MemberExpression node)
            {
                var source = node.Expression as MemberExpression;
                if (source != null && memberPathsMap.TryGetValue(source.Member, out var paths))
                {
                    if (node.Member.DeclaringType == typeof(Array))
                    {
                        if (node.Member.Name == nameof(Array.Length))
                        {
                            return BuildCountExpression(ReplaceExpression(source, paths), CountMethod, paths.ItemType);
                        }
                        else if (node.Member.Name == nameof(Array.LongLength))
                        {
                            return BuildCountExpression(ReplaceExpression(source, paths), LongCountMethod, paths.ItemType);
                        }
                    }
        
                    else if (node.Member.Name == nameof(ICollection<int>.Count) && node.Member.DeclaringType.IsGenericType)
                    {
                        return BuildCountExpression(ReplaceExpression(source, paths), CountMethod, paths.ItemType);
                    }
                }
                return base.VisitMember(node);
            }

            private Expression ReplaceExpression(MemberExpression expression, MemberIncludePath paths)
            {
                Expression exp = expression;
                foreach (var callPath in paths.CallPaths)
                {
                    var arguments = callPath.Arguments.ToArray();
                    arguments[0] = exp;
                    exp = Expression.Call(null, callPath.Method, arguments);
                }
                return exp;
            }
            static MethodInfo ToArrayMethod = typeof(Enumerable).GetMethod(nameof(Enumerable.ToArray));
            static MethodInfo ToListMethod = typeof(Enumerable).GetMethod(nameof(Enumerable.ToList));
            static MethodInfo CountMethod = typeof(Enumerable).GetMethods().Single(p => p.Name == nameof(Enumerable.Count) && p.GetParameters().Length == 1);
            static MethodInfo LongCountMethod = typeof(Enumerable).GetMethods().Single(p => p.Name == nameof(Enumerable.LongCount) && p.GetParameters().Length == 1);
            private Expression ReplaceAndConvertExpression(MemberExpression expression, MemberIncludePath paths)
            {
                var returnType = expression.Type;
                Expression exp = expression;
                Type expressionReturnType = expression.Type;
                foreach (var callPath in paths.CallPaths)
                {
                    var arguments = callPath.Arguments.ToArray();
                    arguments[0] = exp;
                    exp = Expression.Call(null, callPath.Method, arguments);
                    expressionReturnType = callPath.Method.ReturnType;
                }
                if (expressionReturnType == returnType)
                {
                    return exp;
                }
                else if (returnType.IsArray)
                {
                    return Expression.Call(null, ToArrayMethod.MakeGenericMethod(paths.ItemType), exp);
                }
                else if (returnType.IsAssignableFrom(typeof(List<>).MakeGenericType(paths.ItemType)))
                {
                    return Expression.Call(null, ToListMethod.MakeGenericMethod(paths.ItemType), exp);
                }
                else
                {
                    return expression;
                }
            }
            private Expression BuildCountExpression(Expression expression, MethodInfo genericCountMethod, Type itemType)
            {
                var method = genericCountMethod.MakeGenericMethod(itemType);
                return Expression.Call(null, method, expression);
            }
        }
        class MemberIncludePath
        {
            public Type ItemType { get; set; }
            public MemberExpression Member { get; set; }
            public List<MethodCallExpression> CallPaths { get; } = new List<MethodCallExpression>();
            public bool HasCallPath { get => CallPaths.Any(); }
        }
    }
#pragma warning restore CS8603,CS8604,CS8618 
}]]></code>
    <code file="FlyTiger.MapperExtensions.g.cs"><![CDATA[#pragma warning disable CS1591
using System;
using System.Collections.Immutable;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
namespace FlyTiger
{
    static class MapperExtensions
    {
        private static IEnumerable<T> EachItem<T>(this IEnumerable<T> source, Action<T> handler)
        {
            foreach (var item in source)
            {
                handler?.Invoke(item);
                yield return item;
            }
        }
        private static void ForEach<T>(this IEnumerable<T> source, Action<T> handler)
        {
            foreach (var item in source)
            {
                handler?.Invoke(item);
            }
        }
        private static global::SourceGenerator.ConvertTo.To ToSourceGenerator_ConvertTo_To(this global::SourceGenerator.ConvertTo.From source)
        {
            if (source == null) return default;
            return new global::SourceGenerator.ConvertTo.To
            {
                StrProp = source.StrProp,
                IntProp = source.IntProp,
                NullableIntProp = source.NullableIntProp,
                NullableIntProp2 = source.NullableIntProp2,
                OneEnumProp = source.OneEnumProp,
                NullableOneEnumProp = source.NullableOneEnumProp,
                NullableOneEnumProp2 = source.NullableOneEnumProp2,
                OneStructProp = source.OneStructProp,
                NullableOneStructProp = source.NullableOneStructProp,
                NullableOneStructProp2 = source.NullableOneStructProp2,
                OneClassProp = source.OneClassProp,
                OneClassProp2 = new global::SourceGenerator.ConvertTo.OtherClass
                {
                    StrProp = source.OneClassProp2.StrProp,
                },
                ClassList = source.ClassList == null ? default : source.ClassList.ToList(),
                ClassList2 = source.ClassList2 == null ? default : source.ClassList2.Select(p => new global::SourceGenerator.ConvertTo.OtherClass
                {
                    StrProp = p.StrProp,
                }).ToList(),
                ArrayStringToArray = source.ArrayStringToArray,
                ArrayStringToList = source.ArrayStringToList == null ? default : source.ArrayStringToList.ToList(),
                ArrayStringToIList = source.ArrayStringToIList,
                ArrayStringToICollection = source.ArrayStringToICollection,
                ArrayStringToIEnumerable = source.ArrayStringToIEnumerable,
                ArrayStringToIQueryable = source.ArrayStringToIQueryable == null ? default : source.ArrayStringToIQueryable.AsQueryable(),
            };
        }
        private static void ToSourceGenerator_ConvertTo_To(this global::SourceGenerator.ConvertTo.From source, global::SourceGenerator.ConvertTo.To target, Action<object> onRemoveItem = null, Action<object> onAddItem = null)
        {
            CopySourceGeneratorConvertToFromToSourceGeneratorConvertToTo(source, target);
            void CopySourceGeneratorConvertToFromToSourceGeneratorConvertToTo(global::SourceGenerator.ConvertTo.From source, global::SourceGenerator.ConvertTo.To target)
            {
                if (source == null) return;
                if (target == null) return;
                target.StrProp = source.StrProp;
                target.IntProp = source.IntProp;
                target.NullableIntProp = source.NullableIntProp;
                target.NullableIntProp2 = source.NullableIntProp2;
                target.OneEnumProp = source.OneEnumProp;
                target.NullableOneEnumProp = source.NullableOneEnumProp;
                target.NullableOneEnumProp2 = source.NullableOneEnumProp2;
                target.OneStructProp = source.OneStructProp;
                target.NullableOneStructProp = source.NullableOneStructProp;
                target.NullableOneStructProp2 = source.NullableOneStructProp2;
                target.OneClassProp = source.OneClassProp;
                target.OneClassProp2 = new global::SourceGenerator.ConvertTo.OtherClass
                {
                    StrProp = source.OneClassProp2.StrProp,
                };
                target.ClassList = source.ClassList == null ? default : source.ClassList.ToList();
                target.ClassList2 = source.ClassList2 == null ? default : source.ClassList2.Select(p => new global::SourceGenerator.ConvertTo.OtherClass
                {
                    StrProp = p.StrProp,
                }).ToList();
                target.ArrayStringToArray = source.ArrayStringToArray == null ? default : source.ArrayStringToArray.ToArray();
                target.ArrayStringToList = source.ArrayStringToList == null ? default : source.ArrayStringToList.ToList();
                target.ArrayStringToIList = source.ArrayStringToIList == null ? default : source.ArrayStringToIList.ToList();
                target.ArrayStringToICollection = source.ArrayStringToICollection == null ? default : source.ArrayStringToICollection.ToList();
                target.ArrayStringToIEnumerable = source.ArrayStringToIEnumerable == null ? default : source.ArrayStringToIEnumerable.ToList();
                target.ArrayStringToIQueryable = source.ArrayStringToIQueryable == null ? default : source.ArrayStringToIQueryable.AsQueryable();
            }
        }
        private static void ToSourceGenerator_ConvertTo_To<T>(this IDictionary<T, global::SourceGenerator.ConvertTo.From> source, IDictionary<T, global::SourceGenerator.ConvertTo.To> target, Action<object> onRemoveItem = null, Action<object> onAddItem = null)
        {
            var sourceKeys = source.Keys;
            var targetKeys = target.Keys;
            // modify item
            sourceKeys.Intersect(targetKeys).ForEach(key =>
            {
                ToSourceGenerator_ConvertTo_To(source[key], target[key], onRemoveItem, onAddItem);
            });
            // remove item
            targetKeys.Except(sourceKeys).ForEach(key =>
            {
                var item = target[key];
                target.Remove(key);
                onRemoveItem?.Invoke(item);
            });
            // add item
            sourceKeys.Except(targetKeys).ForEach(key =>
            {
                var item = source[key].ToSourceGenerator_ConvertTo_To();
                target.Add(key, item);
                onAddItem?.Invoke(item);
            });
        }
        private static void ToSourceGenerator_ConvertTo_To<T>(this IEnumerable<global::SourceGenerator.ConvertTo.From> source, ICollection<global::SourceGenerator.ConvertTo.To> target, CollectionUpdateMode updateMode, Func<global::SourceGenerator.ConvertTo.From, T> sourceItemKeySelector, Func<global::SourceGenerator.ConvertTo.To, T> targetItemKeySelector, Action<object> onRemoveItem = null, Action<object> onAddItem = null)
        {
            if (updateMode == CollectionUpdateMode.Append)
            {
                source.Select(p => p.ToSourceGenerator_ConvertTo_To()).ForEach(p =>
                {
                    target.Add(p);
                    onAddItem?.Invoke(p);
                });
            }
            else
            {
                var sourceKeys = source.Select(sourceItemKeySelector).ToHashSet();
                var targetKeys = target.Select(targetItemKeySelector).ToHashSet();
                // modify item
                sourceKeys.Intersect(targetKeys).ForEach(key =>
                {
                    ToSourceGenerator_ConvertTo_To(
                        source.Where(p => sourceItemKeySelector(p).Equals(key)).First(),
                        target.Where(p => targetItemKeySelector(p).Equals(key)).First(),
                        onRemoveItem, onAddItem);
                });
                // remove item
                if (updateMode == CollectionUpdateMode.Update)
                {
                    target.Where(p => !sourceKeys.Contains(targetItemKeySelector(p))).ToList().ForEach(p =>
                    {
                        target.Remove(p);
                        onRemoveItem?.Invoke(p);
                    });
                }
                // add item
                source.Where(p => !targetKeys.Contains(sourceItemKeySelector(p))).Select(p => p.ToSourceGenerator_ConvertTo_To()).ForEach(p =>
                {
                    target.Add(p);
                    onAddItem?.Invoke(p);
                });
            }
        }
        private static IQueryable<global::SourceGenerator.ConvertTo.To> ToSourceGenerator_ConvertTo_To(this IQueryable<global::SourceGenerator.ConvertTo.From> source)
        {
            return source?.Select(p => new global::SourceGenerator.ConvertTo.To
            {
                StrProp = p.StrProp,
                IntProp = p.IntProp,
                NullableIntProp = p.NullableIntProp,
                NullableIntProp2 = p.NullableIntProp2,
                OneEnumProp = p.OneEnumProp,
                NullableOneEnumProp = p.NullableOneEnumProp,
                NullableOneEnumProp2 = p.NullableOneEnumProp2,
                OneStructProp = p.OneStructProp,
                NullableOneStructProp = p.NullableOneStructProp,
                NullableOneStructProp2 = p.NullableOneStructProp2,
                OneClassProp = p.OneClassProp,
                OneClassProp2 = new global::SourceGenerator.ConvertTo.OtherClass
                {
                    StrProp = p.OneClassProp2.StrProp,
                },
                ClassList = p.ClassList == null ? default : p.ClassList.ToList(),
                ClassList2 = p.ClassList2 == null ? default : p.ClassList2.Select(p => new global::SourceGenerator.ConvertTo.OtherClass
                {
                    StrProp = p.StrProp,
                }).ToList(),
                ArrayStringToArray = p.ArrayStringToArray,
                ArrayStringToList = p.ArrayStringToList == null ? default : p.ArrayStringToList.ToList(),
                ArrayStringToIList = p.ArrayStringToIList,
                ArrayStringToICollection = p.ArrayStringToICollection,
                ArrayStringToIEnumerable = p.ArrayStringToIEnumerable,
                ArrayStringToIQueryable = p.ArrayStringToIQueryable == null ? default : p.ArrayStringToIQueryable.AsQueryable(),
            }).RebuildWithIncludeForEfCore();
        }
        private static global::SourceGenerator.ConvertTo.From ToSourceGenerator_ConvertTo_From(this global::SourceGenerator.ConvertTo.To source)
        {
            if (source == null) return default;
            return new global::SourceGenerator.ConvertTo.From
            {
                StrProp = source.StrProp,
                IntProp = source.IntProp,
                NullableIntProp = source.NullableIntProp,
                OneEnumProp = source.OneEnumProp,
                NullableOneEnumProp = source.NullableOneEnumProp,
                OneStructProp = source.OneStructProp,
                NullableOneStructProp = source.NullableOneStructProp,
                NullableOneStructProp2 = source.NullableOneStructProp2 == null ? default : new global::SourceGenerator.ConvertTo.OneStruct
                {
                    StrProp = source.NullableOneStructProp2.Value.StrProp,
                },
                OneClassProp = source.OneClassProp,
                OneClassProp2 = new global::SourceGenerator.ConvertTo.OneClass
                {
                    StrProp = source.OneClassProp2.StrProp,
                },
                ClassList = source.ClassList,
                ClassList2 = source.ClassList2 == null ? default : source.ClassList2.Select(p => new global::SourceGenerator.ConvertTo.OneClass
                {
                    StrProp = p.StrProp,
                }).ToList(),
                ArrayStringToArray = source.ArrayStringToArray,
                ArrayStringToList = source.ArrayStringToList == null ? default : source.ArrayStringToList.ToArray(),
                ArrayStringToIList = source.ArrayStringToIList == null ? default : source.ArrayStringToIList.ToArray(),
                ArrayStringToICollection = source.ArrayStringToICollection == null ? default : source.ArrayStringToICollection.ToArray(),
                ArrayStringToIEnumerable = source.ArrayStringToIEnumerable == null ? default : source.ArrayStringToIEnumerable.ToArray(),
                ArrayStringToIQueryable = source.ArrayStringToIQueryable == null ? default : source.ArrayStringToIQueryable.ToArray(),
            };
        }
        private static void ToSourceGenerator_ConvertTo_From(this global::SourceGenerator.ConvertTo.To source, global::SourceGenerator.ConvertTo.From target, Action<object> onRemoveItem = null, Action<object> onAddItem = null)
        {
            CopySourceGeneratorConvertToToToSourceGeneratorConvertToFrom(source, target);
            void CopySourceGeneratorConvertToToToSourceGeneratorConvertToFrom(global::SourceGenerator.ConvertTo.To source, global::SourceGenerator.ConvertTo.From target)
            {
                if (source == null) return;
                if (target == null) return;
                target.StrProp = source.StrProp;
                target.IntProp = source.IntProp;
                target.NullableIntProp = source.NullableIntProp;
                target.OneEnumProp = source.OneEnumProp;
                target.NullableOneEnumProp = source.NullableOneEnumProp;
                target.OneStructProp = source.OneStructProp;
                target.NullableOneStructProp = source.NullableOneStructProp;
                target.NullableOneStructProp2 = source.NullableOneStructProp2 == null ? default : new global::SourceGenerator.ConvertTo.OneStruct
                {
                    StrProp = source.NullableOneStructProp2.Value.StrProp,
                };
                target.OneClassProp = source.OneClassProp;
                target.OneClassProp2 = new global::SourceGenerator.ConvertTo.OneClass
                {
                    StrProp = source.OneClassProp2.StrProp,
                };
                target.ClassList = source.ClassList == null ? default : source.ClassList.ToList();
                target.ClassList2 = source.ClassList2 == null ? default : source.ClassList2.Select(p => new global::SourceGenerator.ConvertTo.OneClass
                {
                    StrProp = p.StrProp,
                }).ToList();
                target.ArrayStringToArray = source.ArrayStringToArray == null ? default : source.ArrayStringToArray.ToArray();
                target.ArrayStringToList = source.ArrayStringToList == null ? default : source.ArrayStringToList.ToArray();
                target.ArrayStringToIList = source.ArrayStringToIList == null ? default : source.ArrayStringToIList.ToArray();
                target.ArrayStringToICollection = source.ArrayStringToICollection == null ? default : source.ArrayStringToICollection.ToArray();
                target.ArrayStringToIEnumerable = source.ArrayStringToIEnumerable == null ? default : source.ArrayStringToIEnumerable.ToArray();
                target.ArrayStringToIQueryable = source.ArrayStringToIQueryable == null ? default : source.ArrayStringToIQueryable.ToArray();
            }
        }
        private static void ToSourceGenerator_ConvertTo_From<T>(this IDictionary<T, global::SourceGenerator.ConvertTo.To> source, IDictionary<T, global::SourceGenerator.ConvertTo.From> target, Action<object> onRemoveItem = null, Action<object> onAddItem = null)
        {
            var sourceKeys = source.Keys;
            var targetKeys = target.Keys;
            // modify item
            sourceKeys.Intersect(targetKeys).ForEach(key =>
            {
                ToSourceGenerator_ConvertTo_From(source[key], target[key], onRemoveItem, onAddItem);
            });
            // remove item
            targetKeys.Except(sourceKeys).ForEach(key =>
            {
                var item = target[key];
                target.Remove(key);
                onRemoveItem?.Invoke(item);
            });
            // add item
            sourceKeys.Except(targetKeys).ForEach(key =>
            {
                var item = source[key].ToSourceGenerator_ConvertTo_From();
                target.Add(key, item);
                onAddItem?.Invoke(item);
            });
        }
        private static void ToSourceGenerator_ConvertTo_From<T>(this IEnumerable<global::SourceGenerator.ConvertTo.To> source, ICollection<global::SourceGenerator.ConvertTo.From> target, CollectionUpdateMode updateMode, Func<global::SourceGenerator.ConvertTo.To, T> sourceItemKeySelector, Func<global::SourceGenerator.ConvertTo.From, T> targetItemKeySelector, Action<object> onRemoveItem = null, Action<object> onAddItem = null)
        {
            if (updateMode == CollectionUpdateMode.Append)
            {
                source.Select(p => p.ToSourceGenerator_ConvertTo_From()).ForEach(p =>
                {
                    target.Add(p);
                    onAddItem?.Invoke(p);
                });
            }
            else
            {
                var sourceKeys = source.Select(sourceItemKeySelector).ToHashSet();
                var targetKeys = target.Select(targetItemKeySelector).ToHashSet();
                // modify item
                sourceKeys.Intersect(targetKeys).ForEach(key =>
                {
                    ToSourceGenerator_ConvertTo_From(
                        source.Where(p => sourceItemKeySelector(p).Equals(key)).First(),
                        target.Where(p => targetItemKeySelector(p).Equals(key)).First(),
                        onRemoveItem, onAddItem);
                });
                // remove item
                if (updateMode == CollectionUpdateMode.Update)
                {
                    target.Where(p => !sourceKeys.Contains(targetItemKeySelector(p))).ToList().ForEach(p =>
                    {
                        target.Remove(p);
                        onRemoveItem?.Invoke(p);
                    });
                }
                // add item
                source.Where(p => !targetKeys.Contains(sourceItemKeySelector(p))).Select(p => p.ToSourceGenerator_ConvertTo_From()).ForEach(p =>
                {
                    target.Add(p);
                    onAddItem?.Invoke(p);
                });
            }
        }
        private static IQueryable<global::SourceGenerator.ConvertTo.From> ToSourceGenerator_ConvertTo_From(this IQueryable<global::SourceGenerator.ConvertTo.To> source)
        {
            return source?.Select(p => new global::SourceGenerator.ConvertTo.From
            {
                StrProp = p.StrProp,
                IntProp = p.IntProp,
                NullableIntProp = p.NullableIntProp,
                OneEnumProp = p.OneEnumProp,
                NullableOneEnumProp = p.NullableOneEnumProp,
                OneStructProp = p.OneStructProp,
                NullableOneStructProp = p.NullableOneStructProp,
                NullableOneStructProp2 = p.NullableOneStructProp2 == null ? default : new global::SourceGenerator.ConvertTo.OneStruct
                {
                    StrProp = p.NullableOneStructProp2.Value.StrProp,
                },
                OneClassProp = p.OneClassProp,
                OneClassProp2 = new global::SourceGenerator.ConvertTo.OneClass
                {
                    StrProp = p.OneClassProp2.StrProp,
                },
                ClassList = p.ClassList,
                ClassList2 = p.ClassList2 == null ? default : p.ClassList2.Select(p => new global::SourceGenerator.ConvertTo.OneClass
                {
                    StrProp = p.StrProp,
                }).ToList(),
                ArrayStringToArray = p.ArrayStringToArray,
                ArrayStringToList = p.ArrayStringToList == null ? default : p.ArrayStringToList.ToArray(),
                ArrayStringToIList = p.ArrayStringToIList == null ? default : p.ArrayStringToIList.ToArray(),
                ArrayStringToICollection = p.ArrayStringToICollection == null ? default : p.ArrayStringToICollection.ToArray(),
                ArrayStringToIEnumerable = p.ArrayStringToIEnumerable == null ? default : p.ArrayStringToIEnumerable.ToArray(),
                ArrayStringToIQueryable = p.ArrayStringToIQueryable == null ? default : p.ArrayStringToIQueryable.ToArray(),
            }).RebuildWithIncludeForEfCore();
        }
        private static readonly System.Collections.Concurrent.ConcurrentDictionary<int, Delegate> sourceKeySelectorCache = new System.Collections.Concurrent.ConcurrentDictionary<int, Delegate>();
        private static Func<Source, Key> GetSourceKeySelectorFunc<Source, Key>(Expression<Func<Source, Key>> sourceKeyLambda)
        {
            int cacheKey = typeof(Source).GetHashCode() ^ sourceKeyLambda.ToString().GetHashCode();
            return (Func<Source, Key>)sourceKeySelectorCache.GetOrAdd(cacheKey, (_) =>
            {
                return sourceKeyLambda.Compile();
            });
        }

        private static readonly System.Collections.Concurrent.ConcurrentDictionary<int, Delegate> targetKeySelectorCache = new System.Collections.Concurrent.ConcurrentDictionary<int, Delegate>();
        private static Func<Target, Key> GetTargetKeySelectorFunc<Source, Target, Key>(Expression<Func<Source, Key>> sourceKeyLambda)
        {
            int cacheKey = typeof(Source).GetHashCode() ^ typeof(Target).GetHashCode() ^ sourceKeyLambda.ToString().GetHashCode();
            return (Func<Target, Key>)targetKeySelectorCache.GetOrAdd(cacheKey, (_) =>
            {
                var newParameter = Expression.Parameter(typeof(Target), "p");
                var replacer = new ParameterExpressionReplacer(newParameter);
                var newLambdaBody = replacer.Visit(sourceKeyLambda.Body);
                var newLambda = Expression.Lambda<Func<Target, Key>>(newLambdaBody, newParameter);
                return newLambda.Compile();
            });
        }
        public static T To<T>(this global::SourceGenerator.ConvertTo.From source) where T : new()
        {
            if (source == null) return default;
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                return (T)(object)ToSourceGenerator_ConvertTo_To(source);
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static T To<T>(this global::SourceGenerator.ConvertTo.From source, Action<T> postHandler) where T : class, new()
        {
            var result = source.To<T>();
            postHandler?.Invoke(result);
            return result;
        }
        public static IEnumerable<T> To<T>(this IEnumerable<global::SourceGenerator.ConvertTo.From> source) where T : new()
        {
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                return (IEnumerable<T>)source?.Select(p => p.ToSourceGenerator_ConvertTo_To());
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static IEnumerable<T> To<T>(this IEnumerable<global::SourceGenerator.ConvertTo.From> source, Action<T> postHandler) where T : class, new()
        {
            return source == null || postHandler == null ? source.To<T>() : source.To<T>().EachItem(postHandler);
        }
        public static IDictionary<Key, T> To<Key, T>(this IDictionary<Key, global::SourceGenerator.ConvertTo.From> source) where T : new()
        {
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                return (IDictionary<Key, T>)(source?.ToDictionary(p => p.Key, p => p.Value.ToSourceGenerator_ConvertTo_To()));
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static IDictionary<Key, T> To<Key, T>(this IDictionary<Key, global::SourceGenerator.ConvertTo.From> source, Action<T> postHandler) where T : class, new()
        {
            var res = source?.To<Key, T>();
            res?.ForEach(p => postHandler?.Invoke(p.Value));
            return res;
        }
        public static void To<T>(this global::SourceGenerator.ConvertTo.From source, T target, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class
        {
            _ = source ?? throw new ArgumentNullException(nameof(source));
            _ = target ?? throw new ArgumentNullException(nameof(target));
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                ToSourceGenerator_ConvertTo_To(source, (global::SourceGenerator.ConvertTo.To)(object)target, onRemoveItem, onAddItem);
                return;
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static void To<Key, T>(this IDictionary<Key, global::SourceGenerator.ConvertTo.From> source, IDictionary<Key, T> target, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class, new()
        {
            _ = source ?? throw new ArgumentNullException(nameof(source));
            _ = target ?? throw new ArgumentNullException(nameof(target));
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                ToSourceGenerator_ConvertTo_To(source, (IDictionary<Key, global::SourceGenerator.ConvertTo.To>)target, onRemoveItem, onAddItem);
                return;
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static void To<T, K>(this IEnumerable<global::SourceGenerator.ConvertTo.From> source, ICollection<T> target, CollectionUpdateMode updateMode, Func<global::SourceGenerator.ConvertTo.From, K> sourceItemKeySelector, Func<T, K> targetItemKeySelector, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class, new()
        {
            _ = source ?? throw new ArgumentNullException(nameof(source));
            _ = target ?? throw new ArgumentNullException(nameof(target));
            _ = sourceItemKeySelector ?? throw new ArgumentNullException(nameof(sourceItemKeySelector));
            _ = targetItemKeySelector ?? throw new ArgumentNullException(nameof(targetItemKeySelector));
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                ToSourceGenerator_ConvertTo_To(source, (ICollection<global::SourceGenerator.ConvertTo.To>)target, updateMode, sourceItemKeySelector, (Func<global::SourceGenerator.ConvertTo.To, K>)targetItemKeySelector, onRemoveItem, onAddItem);
                return;
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static void To<T, K>(this IEnumerable<global::SourceGenerator.ConvertTo.From> source, ICollection<T> target, CollectionUpdateMode updateMode, Expression<Func<global::SourceGenerator.ConvertTo.From, K>> sourceItemKeySelector, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class, new()
        {
            _ = sourceItemKeySelector ?? throw new ArgumentNullException(nameof(sourceItemKeySelector));
            var sourceFunc = GetSourceKeySelectorFunc(sourceItemKeySelector);
            var targetFunc = GetTargetKeySelectorFunc<global::SourceGenerator.ConvertTo.From, T, K>(sourceItemKeySelector);
            source.To(target, updateMode, sourceFunc, targetFunc, onRemoveItem, onAddItem);
        }
        public static IQueryable<T> To<T>(this IQueryable<global::SourceGenerator.ConvertTo.From> source) where T : new()
        {
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.To))
            {
                return (IQueryable<T>)ToSourceGenerator_ConvertTo_To(source);
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.From)}' to '{typeof(T)}'.");
        }
        public static T To<T>(this global::SourceGenerator.ConvertTo.To source) where T : new()
        {
            if (source == null) return default;
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                return (T)(object)ToSourceGenerator_ConvertTo_From(source);
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        public static T To<T>(this global::SourceGenerator.ConvertTo.To source, Action<T> postHandler) where T : class, new()
        {
            var result = source.To<T>();
            postHandler?.Invoke(result);
            return result;
        }
        public static IEnumerable<T> To<T>(this IEnumerable<global::SourceGenerator.ConvertTo.To> source) where T : new()
        {
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                return (IEnumerable<T>)source?.Select(p => p.ToSourceGenerator_ConvertTo_From());
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        public static IEnumerable<T> To<T>(this IEnumerable<global::SourceGenerator.ConvertTo.To> source, Action<T> postHandler) where T : class, new()
        {
            return source == null || postHandler == null ? source.To<T>() : source.To<T>().EachItem(postHandler);
        }
        public static IDictionary<Key, T> To<Key, T>(this IDictionary<Key, global::SourceGenerator.ConvertTo.To> source) where T : new()
        {
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                return (IDictionary<Key, T>)(source?.ToDictionary(p => p.Key, p => p.Value.ToSourceGenerator_ConvertTo_From()));
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        public static IDictionary<Key, T> To<Key, T>(this IDictionary<Key, global::SourceGenerator.ConvertTo.To> source, Action<T> postHandler) where T : class, new()
        {
            var res = source?.To<Key, T>();
            res?.ForEach(p => postHandler?.Invoke(p.Value));
            return res;
        }
        public static void To<T>(this global::SourceGenerator.ConvertTo.To source, T target, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class
        {
            _ = source ?? throw new ArgumentNullException(nameof(source));
            _ = target ?? throw new ArgumentNullException(nameof(target));
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                ToSourceGenerator_ConvertTo_From(source, (global::SourceGenerator.ConvertTo.From)(object)target, onRemoveItem, onAddItem);
                return;
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        public static void To<Key, T>(this IDictionary<Key, global::SourceGenerator.ConvertTo.To> source, IDictionary<Key, T> target, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class, new()
        {
            _ = source ?? throw new ArgumentNullException(nameof(source));
            _ = target ?? throw new ArgumentNullException(nameof(target));
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                ToSourceGenerator_ConvertTo_From(source, (IDictionary<Key, global::SourceGenerator.ConvertTo.From>)target, onRemoveItem, onAddItem);
                return;
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        public static void To<T, K>(this IEnumerable<global::SourceGenerator.ConvertTo.To> source, ICollection<T> target, CollectionUpdateMode updateMode, Func<global::SourceGenerator.ConvertTo.To, K> sourceItemKeySelector, Func<T, K> targetItemKeySelector, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class, new()
        {
            _ = source ?? throw new ArgumentNullException(nameof(source));
            _ = target ?? throw new ArgumentNullException(nameof(target));
            _ = sourceItemKeySelector ?? throw new ArgumentNullException(nameof(sourceItemKeySelector));
            _ = targetItemKeySelector ?? throw new ArgumentNullException(nameof(targetItemKeySelector));
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                ToSourceGenerator_ConvertTo_From(source, (ICollection<global::SourceGenerator.ConvertTo.From>)target, updateMode, sourceItemKeySelector, (Func<global::SourceGenerator.ConvertTo.From, K>)targetItemKeySelector, onRemoveItem, onAddItem);
                return;
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        public static void To<T, K>(this IEnumerable<global::SourceGenerator.ConvertTo.To> source, ICollection<T> target, CollectionUpdateMode updateMode, Expression<Func<global::SourceGenerator.ConvertTo.To, K>> sourceItemKeySelector, Action<object> onRemoveItem = null, Action<object> onAddItem = null) where T : class, new()
        {
            _ = sourceItemKeySelector ?? throw new ArgumentNullException(nameof(sourceItemKeySelector));
            var sourceFunc = GetSourceKeySelectorFunc(sourceItemKeySelector);
            var targetFunc = GetTargetKeySelectorFunc<global::SourceGenerator.ConvertTo.To, T, K>(sourceItemKeySelector);
            source.To(target, updateMode, sourceFunc, targetFunc, onRemoveItem, onAddItem);
        }
        public static IQueryable<T> To<T>(this IQueryable<global::SourceGenerator.ConvertTo.To> source) where T : new()
        {
            if (typeof(T) == typeof(global::SourceGenerator.ConvertTo.From))
            {
                return (IQueryable<T>)ToSourceGenerator_ConvertTo_From(source);
            }
            throw new NotSupportedException($"Can not convert '{typeof(global::SourceGenerator.ConvertTo.To)}' to '{typeof(T)}'.");
        }
        private class ParameterExpressionReplacer : ExpressionVisitor
        {
            public ParameterExpressionReplacer(ParameterExpression newParameter)
            {
                this.newParameter = newParameter;
            }
            private readonly ParameterExpression newParameter;

            protected override Expression VisitMember(MemberExpression node)
            {
                if (node.Expression.NodeType == ExpressionType.Parameter)
                {
                    return Expression.PropertyOrField(newParameter, node.Member.Name);
                }
                else
                {
                    return base.VisitMember(node);
                }
            }
        }
    }
}]]></code>
  </output>
</case>